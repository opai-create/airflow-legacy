#include "exploits.h"

#include "../../base/sdk.h"
#include "../../base/sdk/entity.h"
#include "../../base/sdk/c_usercmd.h"

#include "../../base/global_context.h"

#include "../features.h"
#include "../config_vars.h"

#include "../visuals/event/event_logger.h"

#include "../../base/hooks/hooks.h"

void c_tickbase::store(int tickbase, int cmd, int shift, bool restore, int cmd_diff) {
	this->data.tickbase = tickbase;
	this->data.command_number = cmd;
	this->data.shift_amount = shift;
	this->data.restore_tickbase = restore;
	this->data.cmd_diff = cmd_diff;
}

void c_tickbase::fix(int new_command_number, int& tickbase) {
	auto d = this->data;
	if (d.command_number <= 0)
		return;

	if (d.command_number == new_command_number)
		tickbase = d.tickbase - d.shift_amount + interfaces::global_vars->sim_ticks_this_frame;

	if (d.restore_tickbase && d.command_number + d.cmd_diff == new_command_number)
		tickbase += d.shift_amount - interfaces::global_vars->sim_ticks_this_frame;
}

void write_user_cmd(void* buf, c_usercmd* in, c_usercmd* out) {
	__asm {
		mov     ecx, buf
		mov     edx, in
		push    out
		call    func_ptrs::write_user_cmd
		add     esp, 4
	}
}

bool c_exploits::should_shift_cmd(int* new_commands, int* backup_commands, void* ecx, int slot, void* buf, int from, int to) {
	static auto original = vtables[vtables_t::client].original<write_usercmd_fn>(xor_int(23));

	auto newcmds = *new_commands;
	auto shift_amount = std::clamp(shift, 1, 14);

	shift = 0;
	*backup_commands = 0;

	auto choked_modifier = newcmds + shift_amount;

	if (choked_modifier > 62)
		choked_modifier = 62;

	*new_commands = choked_modifier;

	auto final_from = -1;
	auto next_cmdnr = interfaces::client_state->choked_commands + interfaces::client_state->last_outgoing_command + 1;
	auto final_to = next_cmdnr - newcmds + 1;

	if (final_to <= next_cmdnr) {
		while (original(ecx, slot, buf, final_from, final_to, true)) {
			final_from = final_to++;

			if (final_to > next_cmdnr)
				goto next_cmd;
		}

		return false;
	}
next_cmd:

	auto user_cmd = interfaces::input->get_user_cmd(final_from);

	if (!user_cmd)
		return true;

	c_usercmd to_cmd;
	c_usercmd from_cmd;

	from_cmd = *user_cmd;
	to_cmd = from_cmd;

	to_cmd.command_number++;
	to_cmd.tickcount += 200;

	if (newcmds > choked_modifier)
		return true;

	for (auto i = choked_modifier - newcmds + 1; i > 0; --i) {
		write_user_cmd(buf, &to_cmd, &from_cmd);

		from_cmd = to_cmd;
		to_cmd.command_number++;
		to_cmd.tickcount++;
	}

	g_tickbase->simulation_amt = choked_modifier - newcmds + 1;
	return true;
}

void c_exploits::force_shift(c_usercmd* cmd, int amount, bool buffer) {
	if (charge_ticks < amount)
		return;

	if (!stop_movement)
		stop_movement = true;

	if (!teleportshift)
		teleportshift = true;

	shift_tick = g_ctx.cmd->command_number;

	cl_move.shift = true;
	cl_move.amount = amount;
}

bool c_exploits::recharging(c_usercmd* cmd) {
	if (cmd->weaponselect)
		return false;

	static int last_choke = 0;
	if (recharge && !last_choke) {
		if (++charge_ticks >= amounts.recharge) {
			recharge = false;
			recharge_finish = true;
			stop_movement = true;
		}

		shift = 0;

		lag_shift = false;
		toggle_lag = false;
		teleportshift = false;
		return true;
	}
	else
		last_choke = interfaces::client_state->choked_commands;

	return false;
}

void c_exploits::on_pre_predict() {
	this->update_amounts();

	static bool toggle_hs = false;
	static bool toggle_dt = false;

	if (g_cfg.rage.enable && g_cfg.binds[hs_b].toggled) {
		if (!toggle_hs) {
			hs_active = true;
			toggle_hs = true;
		}
	}
	else
		toggle_hs = false;

	if (g_cfg.rage.enable && g_cfg.binds[dt_b].toggled) {
		if (!toggle_dt) {
			dt_active = true;
			toggle_dt = true;
		}
	}
	else
		toggle_dt = false;

	bool active = dt_toggled && dt_active || hs_toggled && hs_active;

	if (charge_ticks < amounts.recharge && active) {
		recharge = true;
		recharge_finish = false;
	}
}

void c_exploits::double_tap() {
	static bool toggle_charge = false;

	if (toggle_charge) {
		toggle_charge = false;
		charge_dt = true;
		this->reset_shift();
		return;
	}

	static int last_dt_tick = 0;

	if (charge_dt) {
		float shot_diff = std::abs(g_ctx.weapon->last_shot_time() - interfaces::global_vars->cur_time);
		bool shot_finish = shot_diff >= 0.3f && !cl_move.shift;
		if (shot_finish && !g_rage_bot->working && !interfaces::client_state->choked_commands) {
			if (!g_cfg.binds[dt_b].toggled)
				teleport = false;
			else
				teleport = true;

			dt_bullet = 0;
			charge_dt = false;
			dt_active = true;
		}
		else if (g_ctx.cmd->buttons & in_attack) {
			dt_bullet++;

			last_dt_tick = interfaces::global_vars->tick_count;
		}

		shift_tick = 0;
		return;
	}

	if (g_anti_aim->is_fake_ducking()) {
		dt_toggled = false;

		if (!dt_off) {
			stop_movement = true;

			if (teleport) {
				this->force_shift(g_ctx.cmd, amounts.dt_shift - 1);
				teleport = false;
			}

			dt_off = true;
		}

		this->reset_shift();

		return;
	}

	if (!g_cfg.binds[dt_b].toggled) {
		dt_toggled = false;

		if (!g_cfg.binds[hs_b].toggled && !dt_off) {
			stop_movement = true;

			if (teleport) {
				this->force_shift(g_ctx.cmd, amounts.dt_shift - 1);
				teleport = false;
			}

			this->reset_shift();

			dt_off = true;
		}
		return;
	}

	dt_toggled = true;
	dt_off = false;

	if (!recharge_finish)
		return;

	if (!teleport)
		teleport = true;

	if (g_ctx.weapon->is_misc_weapon() && !g_ctx.weapon->is_knife() && !g_ctx.weapon->is_taser()) {
		lag_shift = false;
		toggle_lag = false;
		break_lc = true;
		shift = amounts.dt_shift;
		shift_timer = 0;
		return;
	}

	if (!g_ctx.cmd->weaponselect && g_utils->is_firing()) {
		this->force_shift(g_ctx.cmd, amounts.dt_shift - 1, true);

		last_dt_tick = interfaces::global_vars->tick_count;

		dt_bullet++;

		dt_toggled = false;
		dt_active = false;
		lag_shift = false;
		toggle_lag = false;
		toggle_charge = true;
		return;
	}

	if (g_anti_aim->is_peeking() && g_ctx.weapon->item_definition_index() != weapon_revolver && !g_ctx.weapon->is_misc_weapon()) {
		if (!toggle_lag) {
			if (!lag_shift) {
				shift_timer = 0;
				lag_shift = true;
			}

			toggle_lag = true;
		}
	}
	else {
		lag_shift = false;
		toggle_lag = false;
	}

	if (lag_shift) {
		shift = shift_timer > 0 ? amounts.dt_shift : 0;

		if (++shift_timer >= amounts.dt_shift) {
			shift_timer = 0;
			lag_shift = false;
		}
	}
	else {
		shift = amounts.dt_shift;
		shift_timer = 0;
		toggle_lag = false;
	}

	/*static vector3d origin{};
	if (!shift)
		interfaces::debug_overlay->add_text_overlay(g_ctx.local->origin(), 3.f,
			"*");*/
}

void c_exploits::hide_shots() {
	if (g_anti_aim->is_fake_ducking()) {
		hs_toggled = false;
		hs_works = false;

		if (!hs_off) {
			stop_movement = true;
			this->force_shift(g_ctx.cmd, amounts.dt_shift - 1);
			hs_off = true;
		}

		this->reset_shift();
		return;
	}

	if (!g_cfg.binds[hs_b].toggled || g_cfg.binds[dt_b].toggled) {
		hs_toggled = false;
		hs_works = false;

		if (!g_cfg.binds[dt_b].toggled && !hs_off) {
			stop_movement = true;
			this->force_shift(g_ctx.cmd, amounts.dt_shift - 1);
			this->reset_shift();

			hs_off = true;
		}
		return;
	}

	hs_toggled = true;
	hs_off = false;
	hs_works = false;

	if (!recharge_finish)
		return;

	if (g_ctx.weapon->is_misc_weapon() || g_ctx.weapon->item_definition_index() == weapon_revolver)
		return;

	int shift_cnt = amounts.hs_shift;
	if ((g_rage_bot->firing || g_utils->is_firing())) {
		if (*g_ctx.send_packet) {
			hs_works = true;
			shift = shift_cnt;

			//g_tickbase->store(g_ctx.local->tickbase(), g_ctx.cmd->command_number, shift_cnt + 1, true);
		}
		else
			g_ctx.cmd->buttons &= ~in_attack;
	}
	else
		g_ctx.cmd->buttons &= ~in_attack;
}

void c_exploits::on_predict_start() {
	if (cl_move.shift)
		return;

	this->double_tap();
	this->hide_shots();

	if (!g_cfg.binds[ap_b].toggled)
		g_rage_bot->firing = false;
}

void c_exploits::on_cl_move(float sample, bool final_tick) {
	if (!g_ctx.is_alive)
		return;

	if (!cl_move.shift)
		return;

	if (interfaces::client_state->choked_commands == 0) {
		*g_ctx.send_packet = false;
		return;
	}

	static auto original = hooker.original(&tr::engine::cl_move);

	while (cl_move.amount >= 0) {
		if (cl_move.amount >= amounts.dt_shift)
			*g_ctx.send_packet = false;

		g_engine_prediction->update();

		cl_move.shifting = true;
		original(0.f, cl_move.amount <= 0);

		cl_move.amount--;
	}

	cl_move.shift = false;
	cl_move.shifting = false;
}